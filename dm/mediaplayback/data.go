// Code generated by data_gen.go. DO NOT EDIT.

package mediaplayback

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type CharacteristicEnum uint8

const (
	CharacteristicEnumForcedSubtitles CharacteristicEnum = 0
	CharacteristicEnumDescribesVideo CharacteristicEnum = 1
	CharacteristicEnumEasyToRead CharacteristicEnum = 2
	CharacteristicEnumFrameBased CharacteristicEnum = 3
	CharacteristicEnumMainProgram CharacteristicEnum = 4
	CharacteristicEnumOriginalContent CharacteristicEnum = 5
	CharacteristicEnumVoiceOverTranslation CharacteristicEnum = 6
	CharacteristicEnumCaption CharacteristicEnum = 7
	CharacteristicEnumSubtitle CharacteristicEnum = 8
	CharacteristicEnumAlternate CharacteristicEnum = 9
	CharacteristicEnumSupplementary CharacteristicEnum = 10
	CharacteristicEnumCommentary CharacteristicEnum = 11
	CharacteristicEnumDubbedTranslation CharacteristicEnum = 12
	CharacteristicEnumDescription CharacteristicEnum = 13
	CharacteristicEnumMetadata CharacteristicEnum = 14
	CharacteristicEnumEnhancedAudioIntelligibility CharacteristicEnum = 15
	CharacteristicEnumEmergency CharacteristicEnum = 16
	CharacteristicEnumKaraoke CharacteristicEnum = 17
)

type PlaybackStateEnum uint8

const (
	PlaybackStateEnumPlaying PlaybackStateEnum = 0
	PlaybackStateEnumPaused PlaybackStateEnum = 1
	PlaybackStateEnumNotPlaying PlaybackStateEnum = 2
	PlaybackStateEnumBuffering PlaybackStateEnum = 3
)

type StatusEnum uint8

const (
	StatusEnumSuccess StatusEnum = 0
	StatusEnumInvalidStateForCommand StatusEnum = 1
	StatusEnumNotAllowed StatusEnum = 2
	StatusEnumNotActive StatusEnum = 3
	StatusEnumSpeedOutOfRange StatusEnum = 4
	StatusEnumSeekOutOfRange StatusEnum = 5
)



type PlaybackPosition struct {
	UpdatedAt dm.EpochUS // Tag 0
	Position *uint64 // Tag 1
}

func (s *PlaybackPosition) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: UpdatedAt Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.UpdatedAt)
    
	// Field: Position Tag: 1
    if s.Position != nil {
        st[tlv.ContextTag(1)] = uint64(*s.Position)
    }
	return st
}

func (s *PlaybackPosition) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.UpdatedAt = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint64(v)
s.Position = &casted
}
        
        
	}

    return nil
}

type TrackAttributes struct {
	LanguageCode string // Tag 0
	Characteristics []CharacteristicEnum // Tag 1
	DisplayName *string // Tag 2
}

func (s *TrackAttributes) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: LanguageCode Tag: 0
    
        st[tlv.ContextTag(0)] = (s.LanguageCode)
    
	// Field: Characteristics Tag: 1
    if len(s.Characteristics) > 0 {
        
        list := make(tlv.UintArray, 0, len(s.Characteristics))
        for _, v := range s.Characteristics {
            list = append(list, uint64(v))
        }
        st[tlv.ContextTag(1)] = list
        
    }
	// Field: DisplayName Tag: 2
    if s.DisplayName != nil {
        st[tlv.ContextTag(2)] = (*s.DisplayName)
    }
	return st
}

func (s *TrackAttributes) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.LanguageCode = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
            
            if arr, ok := val.(tlv.UintArray); ok {
                 for _, item := range arr {
                     s.Characteristics = append(s.Characteristics, CharacteristicEnum(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(string); ok {
s.DisplayName = &v
}
        
        
	}

    return nil
}

type Track struct {
	ID string // Tag 0
	TrackAttributes TrackAttributes // Tag 1
}

func (s *Track) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: ID Tag: 0
    
        st[tlv.ContextTag(0)] = (s.ID)
    
	// Field: TrackAttributes Tag: 1
    
        st[tlv.ContextTag(1)] = s.TrackAttributes.Encode()
        
    
	return st
}

func (s *Track) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.ID = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        if err := s.TrackAttributes.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

