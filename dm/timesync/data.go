// Code generated by data_gen.go. DO NOT EDIT.

package timesync

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type GranularityEnum uint8

const (
	GranularityEnumNoTimeGranularity GranularityEnum = 0
	GranularityEnumMinutesGranularity GranularityEnum = 1
	GranularityEnumSecondsGranularity GranularityEnum = 2
	GranularityEnumMillisecondsGranularity GranularityEnum = 3
	GranularityEnumMicrosecondsGranularity GranularityEnum = 4
)

type StatusCodeEnum uint8

const (
	StatusCodeEnumTimeNotAccepted StatusCodeEnum = 0x02
)

type TimeSourceEnum uint8

const (
	TimeSourceEnumNone TimeSourceEnum = 0
	TimeSourceEnumUnknown TimeSourceEnum = 1
	TimeSourceEnumAdmin TimeSourceEnum = 2
	TimeSourceEnumNodeTimeCluster TimeSourceEnum = 3
	TimeSourceEnumNonMatterSNTP TimeSourceEnum = 4
	TimeSourceEnumNonMatterNTP TimeSourceEnum = 5
	TimeSourceEnumMatterSNTP TimeSourceEnum = 6
	TimeSourceEnumMatterNTP TimeSourceEnum = 7
	TimeSourceEnumMixedNTP TimeSourceEnum = 8
	TimeSourceEnumNonMatterSNTPNTS TimeSourceEnum = 9
	TimeSourceEnumNonMatterNTPNTS TimeSourceEnum = 10
	TimeSourceEnumMatterSNTPNTS TimeSourceEnum = 11
	TimeSourceEnumMatterNTPNTS TimeSourceEnum = 12
	TimeSourceEnumMixedNTPNTS TimeSourceEnum = 13
	TimeSourceEnumCloudSource TimeSourceEnum = 14
	TimeSourceEnumPTP TimeSourceEnum = 15
	TimeSourceEnumGNSS TimeSourceEnum = 16
)

type TimeZoneDatabaseEnum uint8

const (
	TimeZoneDatabaseEnumFull TimeZoneDatabaseEnum = 0
	TimeZoneDatabaseEnumPartial TimeZoneDatabaseEnum = 1
	TimeZoneDatabaseEnumNone TimeZoneDatabaseEnum = 2
)



type DSTOffset struct {
	Offset int32 // Tag 0
	ValidStarting dm.EpochUS // Tag 1
	ValidUntil *dm.EpochUS // Tag 2
}

func (s *DSTOffset) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Offset Tag: 0
    
        st[tlv.ContextTag(0)] = int64(s.Offset)
    
	// Field: ValidStarting Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.ValidStarting)
    
	// Field: ValidUntil Tag: 2
    if s.ValidUntil != nil {
        st[tlv.ContextTag(2)] = uint64(*s.ValidUntil)
    }
	return st
}

func (s *DSTOffset) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := int32(v)
s.Offset = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.ValidStarting = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.ValidUntil = &casted
}
        
        
	}

    return nil
}

type FabricScopedTrustedTimeSource struct {
	NodeID dm.NodeID // Tag 0
	Endpoint dm.EndpointID // Tag 1
}

func (s *FabricScopedTrustedTimeSource) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: NodeID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.NodeID)
    
	// Field: Endpoint Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Endpoint)
    
	return st
}

func (s *FabricScopedTrustedTimeSource) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.Endpoint = casted
}
        
        
	}

    return nil
}

type TimeZone struct {
	Offset int32 // Tag 0
	ValidAt dm.EpochUS // Tag 1
	Name *string // Tag 2
}

func (s *TimeZone) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Offset Tag: 0
    
        st[tlv.ContextTag(0)] = int64(s.Offset)
    
	// Field: ValidAt Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.ValidAt)
    
	// Field: Name Tag: 2
    if s.Name != nil {
        st[tlv.ContextTag(2)] = (*s.Name)
    }
	return st
}

func (s *TimeZone) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := int32(v)
s.Offset = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.ValidAt = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Name = &v
}
        
        
	}

    return nil
}

type TrustedTimeSource struct {
	FabricIndex dm.FabricIndex // Tag 0
	NodeID dm.NodeID // Tag 1
	Endpoint dm.EndpointID // Tag 2
}

func (s *TrustedTimeSource) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: FabricIndex Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.FabricIndex)
    
	// Field: NodeID Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.NodeID)
    
	// Field: Endpoint Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.Endpoint)
    
	return st
}

func (s *TrustedTimeSource) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.FabricIndex(v)
s.FabricIndex = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.Endpoint = casted
}
        
        
	}

    return nil
}

