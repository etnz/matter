// Code generated by data_gen.go. DO NOT EDIT.

package jfds

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type DatastoreAccessControlEntryAuthModeEnum uint8

const (
	DatastoreAccessControlEntryAuthModeEnumPASE DatastoreAccessControlEntryAuthModeEnum = 1
	DatastoreAccessControlEntryAuthModeEnumCASE DatastoreAccessControlEntryAuthModeEnum = 2
	DatastoreAccessControlEntryAuthModeEnumGroup DatastoreAccessControlEntryAuthModeEnum = 3
)

type DatastoreAccessControlEntryPrivilegeEnum uint8

const (
	DatastoreAccessControlEntryPrivilegeEnumView DatastoreAccessControlEntryPrivilegeEnum = 1
	DatastoreAccessControlEntryPrivilegeEnumProxyView DatastoreAccessControlEntryPrivilegeEnum = 2
	DatastoreAccessControlEntryPrivilegeEnumOperate DatastoreAccessControlEntryPrivilegeEnum = 3
	DatastoreAccessControlEntryPrivilegeEnumManage DatastoreAccessControlEntryPrivilegeEnum = 4
	DatastoreAccessControlEntryPrivilegeEnumAdminister DatastoreAccessControlEntryPrivilegeEnum = 5
)

type DatastoreGroupKeyMulticastPolicyEnum uint8

const (
	DatastoreGroupKeyMulticastPolicyEnumPerGroupID DatastoreGroupKeyMulticastPolicyEnum = 0
	DatastoreGroupKeyMulticastPolicyEnumAllNodes DatastoreGroupKeyMulticastPolicyEnum = 1
)

type DatastoreGroupKeySecurityPolicyEnum uint8

const (
	DatastoreGroupKeySecurityPolicyEnumTrustFirst DatastoreGroupKeySecurityPolicyEnum = 0
)

type DatastoreStateEnum uint8

const (
	DatastoreStateEnumPending DatastoreStateEnum = 0
	DatastoreStateEnumCommitted DatastoreStateEnum = 1
	DatastoreStateEnumDeletePending DatastoreStateEnum = 2
	DatastoreStateEnumCommitFailed DatastoreStateEnum = 3
)



type DatastoreACLEntry struct {
	NodeID dm.NodeID // Tag 0
	ListID uint16 // Tag 1
	ACLEntry DatastoreAccessControlEntry // Tag 2
	StatusEntry DatastoreStatusEntry // Tag 3
}

func (s *DatastoreACLEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: NodeID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.NodeID)
    
	// Field: ListID Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.ListID)
    
	// Field: ACLEntry Tag: 2
    
        st[tlv.ContextTag(2)] = s.ACLEntry.Encode()
        
    
	// Field: StatusEntry Tag: 3
    
        st[tlv.ContextTag(3)] = s.StatusEntry.Encode()
        
    
	return st
}

func (s *DatastoreACLEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.ListID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        if err := s.ACLEntry.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        if err := s.StatusEntry.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type DatastoreAccessControlEntry struct {
	Privilege DatastoreAccessControlEntryPrivilegeEnum // Tag 1
	AuthMode DatastoreAccessControlEntryAuthModeEnum // Tag 2
	Subjects []dm.SubjectID // Tag 3
	Targets []DatastoreAccessControlTarget // Tag 4
}

func (s *DatastoreAccessControlEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Privilege Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Privilege)
    
	// Field: AuthMode Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.AuthMode)
    
	// Field: Subjects Tag: 3
    if len(s.Subjects) > 0 {
        
        list := make(tlv.UintArray, 0, len(s.Subjects))
        for _, v := range s.Subjects {
            list = append(list, uint64(v))
        }
        st[tlv.ContextTag(3)] = list
        
    }
	// Field: Targets Tag: 4
    if len(s.Targets) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.Targets))
        for _, v := range s.Targets {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(4)] = list
        
    }
	return st
}

func (s *DatastoreAccessControlEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := DatastoreAccessControlEntryPrivilegeEnum(v)
s.Privilege = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := DatastoreAccessControlEntryAuthModeEnum(v)
s.AuthMode = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
            
            if arr, ok := val.(tlv.UintArray); ok {
                 for _, item := range arr {
                     s.Subjects = append(s.Subjects, dm.SubjectID(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem DatastoreAccessControlTarget
                    if err := newItem.Decode(item); err != nil { return err }
                    s.Targets = append(s.Targets, newItem)
                 }
            }
            
        
	}

    return nil
}

type DatastoreAccessControlTarget struct {
	Cluster *dm.ClusterID // Tag 0
	Endpoint *dm.EndpointID // Tag 1
	DeviceType *dm.DeviceTypeID // Tag 2
}

func (s *DatastoreAccessControlTarget) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Cluster Tag: 0
    if s.Cluster != nil {
        st[tlv.ContextTag(0)] = uint64(*s.Cluster)
    }
	// Field: Endpoint Tag: 1
    if s.Endpoint != nil {
        st[tlv.ContextTag(1)] = uint64(*s.Endpoint)
    }
	// Field: DeviceType Tag: 2
    if s.DeviceType != nil {
        st[tlv.ContextTag(2)] = uint64(*s.DeviceType)
    }
	return st
}

func (s *DatastoreAccessControlTarget) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ClusterID(v)
s.Cluster = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.Endpoint = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.DeviceTypeID(v)
s.DeviceType = &casted
}
        
        
	}

    return nil
}

type DatastoreAdministratorInformationEntry struct {
	NodeID dm.NodeID // Tag 1
	FriendlyName string // Tag 2
	VendorID dm.VendorID // Tag 3
	ICAC []byte // Tag 4
}

func (s *DatastoreAdministratorInformationEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: NodeID Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.NodeID)
    
	// Field: FriendlyName Tag: 2
    
        st[tlv.ContextTag(2)] = (s.FriendlyName)
    
	// Field: VendorID Tag: 3
    
        st[tlv.ContextTag(3)] = uint64(s.VendorID)
    
	// Field: ICAC Tag: 4
    
        st[tlv.ContextTag(4)] = []byte(s.ICAC)
    
	return st
}

func (s *DatastoreAdministratorInformationEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(string); ok {
s.FriendlyName = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.VendorID(v)
s.VendorID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.ICAC = v
}
        
        
	}

    return nil
}

type DatastoreBindingTarget struct {
	Node dm.NodeID // Tag 1
	Group dm.GroupID // Tag 2
	Endpoint dm.EndpointID // Tag 3
	Cluster *dm.ClusterID // Tag 4
}

func (s *DatastoreBindingTarget) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Node Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Node)
    
	// Field: Group Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.Group)
    
	// Field: Endpoint Tag: 3
    
        st[tlv.ContextTag(3)] = uint64(s.Endpoint)
    
	// Field: Cluster Tag: 4
    if s.Cluster != nil {
        st[tlv.ContextTag(4)] = uint64(*s.Cluster)
    }
	return st
}

func (s *DatastoreBindingTarget) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.Node = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.GroupID(v)
s.Group = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.Endpoint = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ClusterID(v)
s.Cluster = &casted
}
        
        
	}

    return nil
}

type DatastoreEndpointBindingEntry struct {
	NodeID dm.NodeID // Tag 0
	EndpointID dm.EndpointID // Tag 1
	ListID uint16 // Tag 2
	Binding DatastoreBindingTarget // Tag 3
	StatusEntry DatastoreStatusEntry // Tag 4
}

func (s *DatastoreEndpointBindingEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: NodeID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.NodeID)
    
	// Field: EndpointID Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.EndpointID)
    
	// Field: ListID Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.ListID)
    
	// Field: Binding Tag: 3
    
        st[tlv.ContextTag(3)] = s.Binding.Encode()
        
    
	// Field: StatusEntry Tag: 4
    
        st[tlv.ContextTag(4)] = s.StatusEntry.Encode()
        
    
	return st
}

func (s *DatastoreEndpointBindingEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.EndpointID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.ListID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        if err := s.Binding.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        if err := s.StatusEntry.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type DatastoreEndpointEntry struct {
	EndpointID dm.EndpointID // Tag 0
	NodeID dm.NodeID // Tag 1
	FriendlyName string // Tag 2
	StatusEntry DatastoreStatusEntry // Tag 3
}

func (s *DatastoreEndpointEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: EndpointID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.EndpointID)
    
	// Field: NodeID Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.NodeID)
    
	// Field: FriendlyName Tag: 2
    
        st[tlv.ContextTag(2)] = (s.FriendlyName)
    
	// Field: StatusEntry Tag: 3
    
        st[tlv.ContextTag(3)] = s.StatusEntry.Encode()
        
    
	return st
}

func (s *DatastoreEndpointEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.EndpointID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(string); ok {
s.FriendlyName = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        if err := s.StatusEntry.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type DatastoreEndpointGroupIDEntry struct {
	NodeID dm.NodeID // Tag 0
	EndpointID dm.EndpointID // Tag 1
	GroupID dm.GroupID // Tag 2
	StatusEntry DatastoreStatusEntry // Tag 3
}

func (s *DatastoreEndpointGroupIDEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: NodeID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.NodeID)
    
	// Field: EndpointID Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.EndpointID)
    
	// Field: GroupID Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.GroupID)
    
	// Field: StatusEntry Tag: 3
    
        st[tlv.ContextTag(3)] = s.StatusEntry.Encode()
        
    
	return st
}

func (s *DatastoreEndpointGroupIDEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.EndpointID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.GroupID(v)
s.GroupID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        if err := s.StatusEntry.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type DatastoreGroupInformationEntry struct {
	GroupID uint64 // Tag 0
	FriendlyName string // Tag 1
	GroupKeySetID *uint16 // Tag 2
	GroupCAT *uint16 // Tag 3
	GroupCATVersion *uint16 // Tag 4
	GroupPermission DatastoreAccessControlEntryPrivilegeEnum // Tag 5
}

func (s *DatastoreGroupInformationEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: GroupID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.GroupID)
    
	// Field: FriendlyName Tag: 1
    
        st[tlv.ContextTag(1)] = (s.FriendlyName)
    
	// Field: GroupKeySetID Tag: 2
    if s.GroupKeySetID != nil {
        st[tlv.ContextTag(2)] = uint64(*s.GroupKeySetID)
    }
	// Field: GroupCAT Tag: 3
    if s.GroupCAT != nil {
        st[tlv.ContextTag(3)] = uint64(*s.GroupCAT)
    }
	// Field: GroupCATVersion Tag: 4
    if s.GroupCATVersion != nil {
        st[tlv.ContextTag(4)] = uint64(*s.GroupCATVersion)
    }
	// Field: GroupPermission Tag: 5
    
        st[tlv.ContextTag(5)] = uint64(s.GroupPermission)
    
	return st
}

func (s *DatastoreGroupInformationEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint64(v)
s.GroupID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.FriendlyName = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.GroupKeySetID = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.GroupCAT = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.GroupCATVersion = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := DatastoreAccessControlEntryPrivilegeEnum(v)
s.GroupPermission = casted
}
        
        
	}

    return nil
}

type DatastoreGroupKeySet struct {
	GroupKeySetID uint16 // Tag 0
	GroupKeySecurityPolicy DatastoreGroupKeySecurityPolicyEnum // Tag 1
	EpochKey0 *[]byte // Tag 2
	EpochStartTime0 *dm.EpochUS // Tag 3
	EpochKey1 *[]byte // Tag 4
	EpochStartTime1 *dm.EpochUS // Tag 5
	EpochKey2 *[]byte // Tag 6
	EpochStartTime2 *dm.EpochUS // Tag 7
	GroupKeyMulticastPolicy DatastoreGroupKeyMulticastPolicyEnum // Tag 8
}

func (s *DatastoreGroupKeySet) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: GroupKeySetID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.GroupKeySetID)
    
	// Field: GroupKeySecurityPolicy Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.GroupKeySecurityPolicy)
    
	// Field: EpochKey0 Tag: 2
    if s.EpochKey0 != nil {
        st[tlv.ContextTag(2)] = []byte(*s.EpochKey0)
    }
	// Field: EpochStartTime0 Tag: 3
    if s.EpochStartTime0 != nil {
        st[tlv.ContextTag(3)] = uint64(*s.EpochStartTime0)
    }
	// Field: EpochKey1 Tag: 4
    if s.EpochKey1 != nil {
        st[tlv.ContextTag(4)] = []byte(*s.EpochKey1)
    }
	// Field: EpochStartTime1 Tag: 5
    if s.EpochStartTime1 != nil {
        st[tlv.ContextTag(5)] = uint64(*s.EpochStartTime1)
    }
	// Field: EpochKey2 Tag: 6
    if s.EpochKey2 != nil {
        st[tlv.ContextTag(6)] = []byte(*s.EpochKey2)
    }
	// Field: EpochStartTime2 Tag: 7
    if s.EpochStartTime2 != nil {
        st[tlv.ContextTag(7)] = uint64(*s.EpochStartTime2)
    }
	// Field: GroupKeyMulticastPolicy Tag: 8
    
        st[tlv.ContextTag(8)] = uint64(s.GroupKeyMulticastPolicy)
    
	return st
}

func (s *DatastoreGroupKeySet) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.GroupKeySetID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := DatastoreGroupKeySecurityPolicyEnum(v)
s.GroupKeySecurityPolicy = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.EpochKey0 = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.EpochStartTime0 = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.EpochKey1 = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.EpochStartTime1 = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(6)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.EpochKey2 = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(7)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.EpochStartTime2 = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(8)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := DatastoreGroupKeyMulticastPolicyEnum(v)
s.GroupKeyMulticastPolicy = casted
}
        
        
	}

    return nil
}

type DatastoreNodeInformationEntry struct {
	NodeID dm.NodeID // Tag 1
	FriendlyName string // Tag 2
	CommissioningStatusEntry DatastoreStatusEntry // Tag 3
}

func (s *DatastoreNodeInformationEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: NodeID Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.NodeID)
    
	// Field: FriendlyName Tag: 2
    
        st[tlv.ContextTag(2)] = (s.FriendlyName)
    
	// Field: CommissioningStatusEntry Tag: 3
    
        st[tlv.ContextTag(3)] = s.CommissioningStatusEntry.Encode()
        
    
	return st
}

func (s *DatastoreNodeInformationEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(string); ok {
s.FriendlyName = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        if err := s.CommissioningStatusEntry.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type DatastoreNodeKeySetEntry struct {
	NodeID dm.NodeID // Tag 0
	GroupKeySetID uint16 // Tag 1
	StatusEntry DatastoreStatusEntry // Tag 2
}

func (s *DatastoreNodeKeySetEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: NodeID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.NodeID)
    
	// Field: GroupKeySetID Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.GroupKeySetID)
    
	// Field: StatusEntry Tag: 2
    
        st[tlv.ContextTag(2)] = s.StatusEntry.Encode()
        
    
	return st
}

func (s *DatastoreNodeKeySetEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.NodeID(v)
s.NodeID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.GroupKeySetID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        if err := s.StatusEntry.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type DatastoreStatusEntry struct {
	State DatastoreStateEnum // Tag 0
	UpdateTimestamp dm.EpochS // Tag 1
	FailureCode dm.Status // Tag 2
}

func (s *DatastoreStatusEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: State Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.State)
    
	// Field: UpdateTimestamp Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.UpdateTimestamp)
    
	// Field: FailureCode Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.FailureCode)
    
	return st
}

func (s *DatastoreStatusEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := DatastoreStateEnum(v)
s.State = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.UpdateTimestamp = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.Status(v)
s.FailureCode = casted
}
        
        
	}

    return nil
}

