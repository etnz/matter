// Code generated by data_gen.go. DO NOT EDIT.

package grpkey

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type GroupKeyMulticastPolicyEnum uint8

const (
	GroupKeyMulticastPolicyEnumPerGroupID GroupKeyMulticastPolicyEnum = 0
	GroupKeyMulticastPolicyEnumAllNodes GroupKeyMulticastPolicyEnum = 1
)

type GroupKeySecurityPolicyEnum uint8

const (
	GroupKeySecurityPolicyEnumTrustFirst GroupKeySecurityPolicyEnum = 0
	GroupKeySecurityPolicyEnumCacheAndSync GroupKeySecurityPolicyEnum = 1
)



type GroupInfoMap struct {
	GroupId dm.GroupID // Tag 1
	Endpoints []dm.EndpointID // Tag 2
	GroupName *string // Tag 3
}

func (s *GroupInfoMap) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: GroupId Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.GroupId)
    
	// Field: Endpoints Tag: 2
    if len(s.Endpoints) > 0 {
        
        list := make(tlv.UintArray, 0, len(s.Endpoints))
        for _, v := range s.Endpoints {
            list = append(list, uint64(v))
        }
        st[tlv.ContextTag(2)] = list
        
    }
	// Field: GroupName Tag: 3
    if s.GroupName != nil {
        st[tlv.ContextTag(3)] = (*s.GroupName)
    }
	return st
}

func (s *GroupInfoMap) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.GroupID(v)
s.GroupId = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
            
            if arr, ok := val.(tlv.UintArray); ok {
                 for _, item := range arr {
                     s.Endpoints = append(s.Endpoints, dm.EndpointID(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(string); ok {
s.GroupName = &v
}
        
        
	}

    return nil
}

type GroupKeyMap struct {
	GroupId dm.GroupID // Tag 1
	GroupKeySetID uint16 // Tag 2
}

func (s *GroupKeyMap) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: GroupId Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.GroupId)
    
	// Field: GroupKeySetID Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.GroupKeySetID)
    
	return st
}

func (s *GroupKeyMap) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.GroupID(v)
s.GroupId = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.GroupKeySetID = casted
}
        
        
	}

    return nil
}

type GroupKeySet struct {
	GroupKeySetID uint16 // Tag 0
	GroupKeySecurityPolicy GroupKeySecurityPolicyEnum // Tag 1
	EpochKey0 *[]byte // Tag 2
	EpochStartTime0 *dm.EpochUS // Tag 3
	EpochKey1 *[]byte // Tag 4
	EpochStartTime1 *dm.EpochUS // Tag 5
	EpochKey2 *[]byte // Tag 6
	EpochStartTime2 *dm.EpochUS // Tag 7
	GroupKeyMulticastPolicy GroupKeyMulticastPolicyEnum // Tag 8
}

func (s *GroupKeySet) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: GroupKeySetID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.GroupKeySetID)
    
	// Field: GroupKeySecurityPolicy Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.GroupKeySecurityPolicy)
    
	// Field: EpochKey0 Tag: 2
    if s.EpochKey0 != nil {
        st[tlv.ContextTag(2)] = []byte(*s.EpochKey0)
    }
	// Field: EpochStartTime0 Tag: 3
    if s.EpochStartTime0 != nil {
        st[tlv.ContextTag(3)] = uint64(*s.EpochStartTime0)
    }
	// Field: EpochKey1 Tag: 4
    if s.EpochKey1 != nil {
        st[tlv.ContextTag(4)] = []byte(*s.EpochKey1)
    }
	// Field: EpochStartTime1 Tag: 5
    if s.EpochStartTime1 != nil {
        st[tlv.ContextTag(5)] = uint64(*s.EpochStartTime1)
    }
	// Field: EpochKey2 Tag: 6
    if s.EpochKey2 != nil {
        st[tlv.ContextTag(6)] = []byte(*s.EpochKey2)
    }
	// Field: EpochStartTime2 Tag: 7
    if s.EpochStartTime2 != nil {
        st[tlv.ContextTag(7)] = uint64(*s.EpochStartTime2)
    }
	// Field: GroupKeyMulticastPolicy Tag: 8
    
        st[tlv.ContextTag(8)] = uint64(s.GroupKeyMulticastPolicy)
    
	return st
}

func (s *GroupKeySet) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.GroupKeySetID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := GroupKeySecurityPolicyEnum(v)
s.GroupKeySecurityPolicy = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.EpochKey0 = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.EpochStartTime0 = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.EpochKey1 = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.EpochStartTime1 = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(6)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.EpochKey2 = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(7)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochUS(v)
s.EpochStartTime2 = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(8)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := GroupKeyMulticastPolicyEnum(v)
s.GroupKeyMulticastPolicy = casted
}
        
        
	}

    return nil
}

