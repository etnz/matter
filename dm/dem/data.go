// Code generated by data_gen.go. DO NOT EDIT.

package dem

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type AdjustmentCauseEnum uint8

const (
	AdjustmentCauseEnumLocalOptimization AdjustmentCauseEnum = 0
	AdjustmentCauseEnumGridOptimization AdjustmentCauseEnum = 1
)

type CauseEnum uint8

const (
	CauseEnumNormalCompletion CauseEnum = 0
	CauseEnumOffline CauseEnum = 1
	CauseEnumFault CauseEnum = 2
	CauseEnumUserOptOut CauseEnum = 3
	CauseEnumCancelled CauseEnum = 4
)

type CostTypeEnum uint8

const (
	CostTypeEnumFinancial CostTypeEnum = 0
	CostTypeEnumGHGEmissions CostTypeEnum = 1
	CostTypeEnumComfort CostTypeEnum = 2
	CostTypeEnumTemperature CostTypeEnum = 3
)

type ESAStateEnum uint8

const (
	ESAStateEnumOffline ESAStateEnum = 0
	ESAStateEnumOnline ESAStateEnum = 1
	ESAStateEnumFault ESAStateEnum = 2
	ESAStateEnumPowerAdjustActive ESAStateEnum = 3
	ESAStateEnumPaused ESAStateEnum = 4
)

type ESATypeEnum uint8

const (
	ESATypeEnumEVSE ESATypeEnum = 0
	ESATypeEnumSpaceHeating ESATypeEnum = 1
	ESATypeEnumWaterHeating ESATypeEnum = 2
	ESATypeEnumSpaceCooling ESATypeEnum = 3
	ESATypeEnumSpaceHeatingCooling ESATypeEnum = 4
	ESATypeEnumBatteryStorage ESATypeEnum = 5
	ESATypeEnumSolarPV ESATypeEnum = 6
	ESATypeEnumFridgeFreezer ESATypeEnum = 7
	ESATypeEnumWashingMachine ESATypeEnum = 8
	ESATypeEnumDishwasher ESATypeEnum = 9
	ESATypeEnumCooking ESATypeEnum = 10
	ESATypeEnumHomeWaterPump ESATypeEnum = 11
	ESATypeEnumIrrigationWaterPump ESATypeEnum = 12
	ESATypeEnumPoolPump ESATypeEnum = 13
	ESATypeEnumOther ESATypeEnum = 255
)

type ForecastUpdateReasonEnum uint8

const (
	ForecastUpdateReasonEnumInternalOptimization ForecastUpdateReasonEnum = 0
	ForecastUpdateReasonEnumLocalOptimization ForecastUpdateReasonEnum = 1
	ForecastUpdateReasonEnumGridOptimization ForecastUpdateReasonEnum = 2
)

type OptOutStateEnum uint8

const (
	OptOutStateEnumNoOptOut OptOutStateEnum = 0
	OptOutStateEnumLocalOptOut OptOutStateEnum = 1
	OptOutStateEnumGridOptOut OptOutStateEnum = 2
	OptOutStateEnumOptOut OptOutStateEnum = 3
)

type PowerAdjustReasonEnum uint8

const (
	PowerAdjustReasonEnumNoAdjustment PowerAdjustReasonEnum = 0
	PowerAdjustReasonEnumLocalOptimizationAdjustment PowerAdjustReasonEnum = 1
	PowerAdjustReasonEnumGridOptimizationAdjustment PowerAdjustReasonEnum = 2
)



type Constraints struct {
	StartTime dm.EpochS // Tag 0
	Duration dm.ElapsedS // Tag 1
	NominalPower dm.PowerMW // Tag 2
	MaximumEnergy dm.EnergyMWh // Tag 3
	LoadControl int8 // Tag 4
}

func (s *Constraints) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: StartTime Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.StartTime)
    
	// Field: Duration Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Duration)
    
	// Field: NominalPower Tag: 2
    
        st[tlv.ContextTag(2)] = int64(s.NominalPower)
    
	// Field: MaximumEnergy Tag: 3
    
        st[tlv.ContextTag(3)] = int64(s.MaximumEnergy)
    
	// Field: LoadControl Tag: 4
    
        st[tlv.ContextTag(4)] = int64(s.LoadControl)
    
	return st
}

func (s *Constraints) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.StartTime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.Duration = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.NominalPower = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.EnergyMWh(v)
s.MaximumEnergy = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := int8(v)
s.LoadControl = casted
}
        
        
	}

    return nil
}

type Cost struct {
	CostType CostTypeEnum // Tag 0
	Value int32 // Tag 1
	DecimalPoints uint8 // Tag 2
	Currency *uint16 // Tag 3
}

func (s *Cost) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: CostType Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.CostType)
    
	// Field: Value Tag: 1
    
        st[tlv.ContextTag(1)] = int64(s.Value)
    
	// Field: DecimalPoints Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.DecimalPoints)
    
	// Field: Currency Tag: 3
    if s.Currency != nil {
        st[tlv.ContextTag(3)] = uint64(*s.Currency)
    }
	return st
}

func (s *Cost) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := CostTypeEnum(v)
s.CostType = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := int32(v)
s.Value = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint8(v)
s.DecimalPoints = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.Currency = &casted
}
        
        
	}

    return nil
}

type Forecast struct {
	ForecastID uint32 // Tag 0
	ActiveSlotNumber *uint16 // Tag 1
	StartTime dm.EpochS // Tag 2
	EndTime dm.EpochS // Tag 3
	EarliestStartTime *dm.EpochS // Tag 4
	LatestEndTime dm.EpochS // Tag 5
	IsPausable bool // Tag 6
	Slots []Slot // Tag 7
	ForecastUpdateReason ForecastUpdateReasonEnum // Tag 8
}

func (s *Forecast) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: ForecastID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.ForecastID)
    
	// Field: ActiveSlotNumber Tag: 1
    if s.ActiveSlotNumber != nil {
        st[tlv.ContextTag(1)] = uint64(*s.ActiveSlotNumber)
    }
	// Field: StartTime Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.StartTime)
    
	// Field: EndTime Tag: 3
    
        st[tlv.ContextTag(3)] = uint64(s.EndTime)
    
	// Field: EarliestStartTime Tag: 4
    if s.EarliestStartTime != nil {
        st[tlv.ContextTag(4)] = uint64(*s.EarliestStartTime)
    }
	// Field: LatestEndTime Tag: 5
    
        st[tlv.ContextTag(5)] = uint64(s.LatestEndTime)
    
	// Field: IsPausable Tag: 6
    
        st[tlv.ContextTag(6)] = (s.IsPausable)
    
	// Field: Slots Tag: 7
    if len(s.Slots) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.Slots))
        for _, v := range s.Slots {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(7)] = list
        
    }
	// Field: ForecastUpdateReason Tag: 8
    
        st[tlv.ContextTag(8)] = uint64(s.ForecastUpdateReason)
    
	return st
}

func (s *Forecast) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint32(v)
s.ForecastID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.ActiveSlotNumber = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.StartTime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.EndTime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.EarliestStartTime = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.LatestEndTime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(6)]; ok {
        
        
            if v, ok := val.(bool); ok {
s.IsPausable = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(7)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem Slot
                    if err := newItem.Decode(item); err != nil { return err }
                    s.Slots = append(s.Slots, newItem)
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(8)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := ForecastUpdateReasonEnum(v)
s.ForecastUpdateReason = casted
}
        
        
	}

    return nil
}

type PowerAdjustCapability struct {
	PowerAdjustCapability []PowerAdjust // Tag 0
	Cause PowerAdjustReasonEnum // Tag 1
}

func (s *PowerAdjustCapability) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: PowerAdjustCapability Tag: 0
    if len(s.PowerAdjustCapability) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.PowerAdjustCapability))
        for _, v := range s.PowerAdjustCapability {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(0)] = list
        
    }
	// Field: Cause Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Cause)
    
	return st
}

func (s *PowerAdjustCapability) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem PowerAdjust
                    if err := newItem.Decode(item); err != nil { return err }
                    s.PowerAdjustCapability = append(s.PowerAdjustCapability, newItem)
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := PowerAdjustReasonEnum(v)
s.Cause = casted
}
        
        
	}

    return nil
}

type PowerAdjust struct {
	MinPower dm.PowerMW // Tag 0
	MaxPower dm.PowerMW // Tag 1
	MinDuration dm.ElapsedS // Tag 2
	MaxDuration dm.ElapsedS // Tag 3
}

func (s *PowerAdjust) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: MinPower Tag: 0
    
        st[tlv.ContextTag(0)] = int64(s.MinPower)
    
	// Field: MaxPower Tag: 1
    
        st[tlv.ContextTag(1)] = int64(s.MaxPower)
    
	// Field: MinDuration Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.MinDuration)
    
	// Field: MaxDuration Tag: 3
    
        st[tlv.ContextTag(3)] = uint64(s.MaxDuration)
    
	return st
}

func (s *PowerAdjust) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.MinPower = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.MaxPower = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.MinDuration = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.MaxDuration = casted
}
        
        
	}

    return nil
}

type SlotAdjustment struct {
	SlotIndex uint8 // Tag 0
	NominalPower dm.PowerMW // Tag 1
	Duration dm.ElapsedS // Tag 2
}

func (s *SlotAdjustment) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: SlotIndex Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.SlotIndex)
    
	// Field: NominalPower Tag: 1
    
        st[tlv.ContextTag(1)] = int64(s.NominalPower)
    
	// Field: Duration Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.Duration)
    
	return st
}

func (s *SlotAdjustment) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint8(v)
s.SlotIndex = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.NominalPower = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.Duration = casted
}
        
        
	}

    return nil
}

type Slot struct {
	MinDuration dm.ElapsedS // Tag 0
	MaxDuration dm.ElapsedS // Tag 1
	DefaultDuration dm.ElapsedS // Tag 2
	ElapsedSlotTime dm.ElapsedS // Tag 3
	RemainingSlotTime dm.ElapsedS // Tag 4
	SlotIsPausable bool // Tag 5
	MinPauseDuration dm.ElapsedS // Tag 6
	MaxPauseDuration dm.ElapsedS // Tag 7
	ManufacturerESAState uint16 // Tag 8
	NominalPower dm.PowerMW // Tag 9
	MinPower dm.PowerMW // Tag 10
	MaxPower dm.PowerMW // Tag 11
	NominalEnergy dm.EnergyMWh // Tag 12
	Costs []Cost // Tag 13
	MinPowerAdjustment dm.PowerMW // Tag 14
	MaxPowerAdjustment dm.PowerMW // Tag 15
	MinDurationAdjustment dm.ElapsedS // Tag 16
	MaxDurationAdjustment dm.ElapsedS // Tag 17
}

func (s *Slot) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: MinDuration Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.MinDuration)
    
	// Field: MaxDuration Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.MaxDuration)
    
	// Field: DefaultDuration Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.DefaultDuration)
    
	// Field: ElapsedSlotTime Tag: 3
    
        st[tlv.ContextTag(3)] = uint64(s.ElapsedSlotTime)
    
	// Field: RemainingSlotTime Tag: 4
    
        st[tlv.ContextTag(4)] = uint64(s.RemainingSlotTime)
    
	// Field: SlotIsPausable Tag: 5
    
        st[tlv.ContextTag(5)] = (s.SlotIsPausable)
    
	// Field: MinPauseDuration Tag: 6
    
        st[tlv.ContextTag(6)] = uint64(s.MinPauseDuration)
    
	// Field: MaxPauseDuration Tag: 7
    
        st[tlv.ContextTag(7)] = uint64(s.MaxPauseDuration)
    
	// Field: ManufacturerESAState Tag: 8
    
        st[tlv.ContextTag(8)] = uint64(s.ManufacturerESAState)
    
	// Field: NominalPower Tag: 9
    
        st[tlv.ContextTag(9)] = int64(s.NominalPower)
    
	// Field: MinPower Tag: 10
    
        st[tlv.ContextTag(10)] = int64(s.MinPower)
    
	// Field: MaxPower Tag: 11
    
        st[tlv.ContextTag(11)] = int64(s.MaxPower)
    
	// Field: NominalEnergy Tag: 12
    
        st[tlv.ContextTag(12)] = int64(s.NominalEnergy)
    
	// Field: Costs Tag: 13
    if len(s.Costs) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.Costs))
        for _, v := range s.Costs {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(13)] = list
        
    }
	// Field: MinPowerAdjustment Tag: 14
    
        st[tlv.ContextTag(14)] = int64(s.MinPowerAdjustment)
    
	// Field: MaxPowerAdjustment Tag: 15
    
        st[tlv.ContextTag(15)] = int64(s.MaxPowerAdjustment)
    
	// Field: MinDurationAdjustment Tag: 16
    
        st[tlv.ContextTag(16)] = uint64(s.MinDurationAdjustment)
    
	// Field: MaxDurationAdjustment Tag: 17
    
        st[tlv.ContextTag(17)] = uint64(s.MaxDurationAdjustment)
    
	return st
}

func (s *Slot) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.MinDuration = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.MaxDuration = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.DefaultDuration = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.ElapsedSlotTime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.RemainingSlotTime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        
            if v, ok := val.(bool); ok {
s.SlotIsPausable = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(6)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.MinPauseDuration = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(7)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.MaxPauseDuration = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(8)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.ManufacturerESAState = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(9)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.NominalPower = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(10)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.MinPower = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(11)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.MaxPower = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(12)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.EnergyMWh(v)
s.NominalEnergy = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(13)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem Cost
                    if err := newItem.Decode(item); err != nil { return err }
                    s.Costs = append(s.Costs, newItem)
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(14)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.MinPowerAdjustment = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(15)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.PowerMW(v)
s.MaxPowerAdjustment = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(16)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.MinDurationAdjustment = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(17)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ElapsedS(v)
s.MaxDurationAdjustment = casted
}
        
        
	}

    return nil
}

