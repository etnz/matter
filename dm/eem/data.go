// Code generated by data_gen.go. DO NOT EDIT.

package eem

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()







type CumulativeEnergyReset struct {
	ImportedResetTimestamp *dm.EpochS // Tag 0
	ExportedResetTimestamp *dm.EpochS // Tag 1
	ImportedResetSystime *dm.SystemTimeMS // Tag 2
	ExportedResetSystime *dm.SystemTimeMS // Tag 3
}

func (s *CumulativeEnergyReset) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: ImportedResetTimestamp Tag: 0
    if s.ImportedResetTimestamp != nil {
        st[tlv.ContextTag(0)] = uint64(*s.ImportedResetTimestamp)
    }
	// Field: ExportedResetTimestamp Tag: 1
    if s.ExportedResetTimestamp != nil {
        st[tlv.ContextTag(1)] = uint64(*s.ExportedResetTimestamp)
    }
	// Field: ImportedResetSystime Tag: 2
    if s.ImportedResetSystime != nil {
        st[tlv.ContextTag(2)] = uint64(*s.ImportedResetSystime)
    }
	// Field: ExportedResetSystime Tag: 3
    if s.ExportedResetSystime != nil {
        st[tlv.ContextTag(3)] = uint64(*s.ExportedResetSystime)
    }
	return st
}

func (s *CumulativeEnergyReset) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.ImportedResetTimestamp = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.ExportedResetTimestamp = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.SystemTimeMS(v)
s.ImportedResetSystime = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.SystemTimeMS(v)
s.ExportedResetSystime = &casted
}
        
        
	}

    return nil
}

type EnergyMeasurement struct {
	Energy dm.EnergyMWh // Tag 0
	StartTimestamp dm.EpochS // Tag 1
	EndTimestamp dm.EpochS // Tag 2
	StartSystime dm.SystemTimeMS // Tag 3
	EndSystime dm.SystemTimeMS // Tag 4
}

func (s *EnergyMeasurement) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Energy Tag: 0
    
        st[tlv.ContextTag(0)] = int64(s.Energy)
    
	// Field: StartTimestamp Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.StartTimestamp)
    
	// Field: EndTimestamp Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.EndTimestamp)
    
	// Field: StartSystime Tag: 3
    
        st[tlv.ContextTag(3)] = uint64(s.StartSystime)
    
	// Field: EndSystime Tag: 4
    
        st[tlv.ContextTag(4)] = uint64(s.EndSystime)
    
	return st
}

func (s *EnergyMeasurement) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(int64); ok {
casted := dm.EnergyMWh(v)
s.Energy = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.StartTimestamp = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.EndTimestamp = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.SystemTimeMS(v)
s.StartSystime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.SystemTimeMS(v)
s.EndSystime = casted
}
        
        
	}

    return nil
}

