// Code generated by data_gen.go. DO NOT EDIT.

package acl

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type AccessControlEntryAuthModeEnum uint8

const (
	AccessControlEntryAuthModeEnumPASE AccessControlEntryAuthModeEnum = 1
	AccessControlEntryAuthModeEnumCASE AccessControlEntryAuthModeEnum = 2
	AccessControlEntryAuthModeEnumGroup AccessControlEntryAuthModeEnum = 3
)

type AccessControlEntryPrivilegeEnum uint8

const (
	AccessControlEntryPrivilegeEnumView AccessControlEntryPrivilegeEnum = 1
	AccessControlEntryPrivilegeEnumProxyView AccessControlEntryPrivilegeEnum = 2
	AccessControlEntryPrivilegeEnumOperate AccessControlEntryPrivilegeEnum = 3
	AccessControlEntryPrivilegeEnumManage AccessControlEntryPrivilegeEnum = 4
	AccessControlEntryPrivilegeEnumAdminister AccessControlEntryPrivilegeEnum = 5
)

type AccessRestrictionTypeEnum uint8

const (
	AccessRestrictionTypeEnumAttributeAccessForbidden AccessRestrictionTypeEnum = 0
	AccessRestrictionTypeEnumAttributeWriteForbidden AccessRestrictionTypeEnum = 1
	AccessRestrictionTypeEnumCommandForbidden AccessRestrictionTypeEnum = 2
	AccessRestrictionTypeEnumEventForbidden AccessRestrictionTypeEnum = 3
)

type ChangeTypeEnum uint8

const (
	ChangeTypeEnumChanged ChangeTypeEnum = 0
	ChangeTypeEnumAdded ChangeTypeEnum = 1
	ChangeTypeEnumRemoved ChangeTypeEnum = 2
)



type AccessControlEntry struct {
	Privilege AccessControlEntryPrivilegeEnum // Tag 1
	AuthMode AccessControlEntryAuthModeEnum // Tag 2
	Subjects []dm.SubjectID // Tag 3
	Targets []AccessControlTarget // Tag 4
}

func (s *AccessControlEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Privilege Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Privilege)
    
	// Field: AuthMode Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.AuthMode)
    
	// Field: Subjects Tag: 3
    if len(s.Subjects) > 0 {
        
        list := make(tlv.UintArray, 0, len(s.Subjects))
        for _, v := range s.Subjects {
            list = append(list, uint64(v))
        }
        st[tlv.ContextTag(3)] = list
        
    }
	// Field: Targets Tag: 4
    if len(s.Targets) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.Targets))
        for _, v := range s.Targets {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(4)] = list
        
    }
	return st
}

func (s *AccessControlEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := AccessControlEntryPrivilegeEnum(v)
s.Privilege = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := AccessControlEntryAuthModeEnum(v)
s.AuthMode = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
            
            if arr, ok := val.(tlv.UintArray); ok {
                 for _, item := range arr {
                     s.Subjects = append(s.Subjects, dm.SubjectID(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem AccessControlTarget
                    if err := newItem.Decode(item); err != nil { return err }
                    s.Targets = append(s.Targets, newItem)
                 }
            }
            
        
	}

    return nil
}

type AccessControlExtension struct {
	Data []byte // Tag 1
}

func (s *AccessControlExtension) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Data Tag: 1
    
        st[tlv.ContextTag(1)] = []byte(s.Data)
    
	return st
}

func (s *AccessControlExtension) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.Data = v
}
        
        
	}

    return nil
}

type AccessControlTarget struct {
	Cluster *dm.ClusterID // Tag 0
	Endpoint *dm.EndpointID // Tag 1
	DeviceType *dm.DeviceTypeID // Tag 2
}

func (s *AccessControlTarget) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Cluster Tag: 0
    if s.Cluster != nil {
        st[tlv.ContextTag(0)] = uint64(*s.Cluster)
    }
	// Field: Endpoint Tag: 1
    if s.Endpoint != nil {
        st[tlv.ContextTag(1)] = uint64(*s.Endpoint)
    }
	// Field: DeviceType Tag: 2
    if s.DeviceType != nil {
        st[tlv.ContextTag(2)] = uint64(*s.DeviceType)
    }
	return st
}

func (s *AccessControlTarget) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ClusterID(v)
s.Cluster = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.Endpoint = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.DeviceTypeID(v)
s.DeviceType = &casted
}
        
        
	}

    return nil
}

type AccessRestrictionEntry struct {
	Endpoint dm.EndpointID // Tag 0
	Cluster dm.ClusterID // Tag 1
	Restrictions []AccessRestriction // Tag 2
}

func (s *AccessRestrictionEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Endpoint Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.Endpoint)
    
	// Field: Cluster Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Cluster)
    
	// Field: Restrictions Tag: 2
    if len(s.Restrictions) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.Restrictions))
        for _, v := range s.Restrictions {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(2)] = list
        
    }
	return st
}

func (s *AccessRestrictionEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.Endpoint = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ClusterID(v)
s.Cluster = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem AccessRestriction
                    if err := newItem.Decode(item); err != nil { return err }
                    s.Restrictions = append(s.Restrictions, newItem)
                 }
            }
            
        
	}

    return nil
}

type AccessRestriction struct {
	Type AccessRestrictionTypeEnum // Tag 0
	ID *uint32 // Tag 1
}

func (s *AccessRestriction) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Type Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.Type)
    
	// Field: ID Tag: 1
    if s.ID != nil {
        st[tlv.ContextTag(1)] = uint64(*s.ID)
    }
	return st
}

func (s *AccessRestriction) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := AccessRestrictionTypeEnum(v)
s.Type = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint32(v)
s.ID = &casted
}
        
        
	}

    return nil
}

type CommissioningAccessRestrictionEntry struct {
	Endpoint dm.EndpointID // Tag 0
	Cluster dm.ClusterID // Tag 1
	Restrictions []AccessRestriction // Tag 2
}

func (s *CommissioningAccessRestrictionEntry) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Endpoint Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.Endpoint)
    
	// Field: Cluster Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Cluster)
    
	// Field: Restrictions Tag: 2
    if len(s.Restrictions) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.Restrictions))
        for _, v := range s.Restrictions {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(2)] = list
        
    }
	return st
}

func (s *CommissioningAccessRestrictionEntry) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EndpointID(v)
s.Endpoint = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.ClusterID(v)
s.Cluster = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem AccessRestriction
                    if err := newItem.Decode(item); err != nil { return err }
                    s.Restrictions = append(s.Restrictions, newItem)
                 }
            }
            
        
	}

    return nil
}

