// Code generated by data_gen.go. DO NOT EDIT.

package channel

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
	"github.com/etnz/matter/dm/contentlauncher"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type ChannelTypeEnum uint8

const (
	ChannelTypeEnumSatellite ChannelTypeEnum = 0
	ChannelTypeEnumCable ChannelTypeEnum = 1
	ChannelTypeEnumTerrestrial ChannelTypeEnum = 2
	ChannelTypeEnumOTT ChannelTypeEnum = 3
)

type LineupInfoTypeEnum uint8

const (
	LineupInfoTypeEnumMSO LineupInfoTypeEnum = 0
)

type StatusEnum uint8

const (
	StatusEnumSuccess StatusEnum = 0
	StatusEnumMultipleMatches StatusEnum = 1
	StatusEnumNoMatches StatusEnum = 2
)

type RecordingFlagBitmap uint8

const (
	RecordingFlagBitmapScheduled RecordingFlagBitmap = 0x1
	RecordingFlagBitmapRecordSeries RecordingFlagBitmap = 0x2
	RecordingFlagBitmapRecorded RecordingFlagBitmap = 0x4
)



type ChannelInfo struct {
	MajorNumber uint16 // Tag 0
	MinorNumber uint16 // Tag 1
	Name *string // Tag 2
	CallSign *string // Tag 3
	AffiliateCallSign *string // Tag 4
	Identifier *string // Tag 5
	Type *ChannelTypeEnum // Tag 6
}

func (s *ChannelInfo) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: MajorNumber Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.MajorNumber)
    
	// Field: MinorNumber Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.MinorNumber)
    
	// Field: Name Tag: 2
    if s.Name != nil {
        st[tlv.ContextTag(2)] = (*s.Name)
    }
	// Field: CallSign Tag: 3
    if s.CallSign != nil {
        st[tlv.ContextTag(3)] = (*s.CallSign)
    }
	// Field: AffiliateCallSign Tag: 4
    if s.AffiliateCallSign != nil {
        st[tlv.ContextTag(4)] = (*s.AffiliateCallSign)
    }
	// Field: Identifier Tag: 5
    if s.Identifier != nil {
        st[tlv.ContextTag(5)] = (*s.Identifier)
    }
	// Field: Type Tag: 6
    if s.Type != nil {
        st[tlv.ContextTag(6)] = uint64(*s.Type)
    }
	return st
}

func (s *ChannelInfo) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.MajorNumber = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.MinorNumber = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Name = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(string); ok {
s.CallSign = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(string); ok {
s.AffiliateCallSign = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Identifier = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(6)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := ChannelTypeEnum(v)
s.Type = &casted
}
        
        
	}

    return nil
}

type ChannelPaging struct {
	PreviousToken *PageToken // Tag 0
	NextToken *PageToken // Tag 1
}

func (s *ChannelPaging) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: PreviousToken Tag: 0
    if s.PreviousToken != nil {
        st[tlv.ContextTag(0)] = s.PreviousToken.Encode()
        
    }
	// Field: NextToken Tag: 1
    if s.NextToken != nil {
        st[tlv.ContextTag(1)] = s.NextToken.Encode()
        
    }
	return st
}

func (s *ChannelPaging) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        s.PreviousToken = &PageToken{}
        if err := s.PreviousToken.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        s.NextToken = &PageToken{}
        if err := s.NextToken.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type LineupInfo struct {
	OperatorName string // Tag 0
	LineupName *string // Tag 1
	PostalCode *string // Tag 2
	LineupInfoType LineupInfoTypeEnum // Tag 3
}

func (s *LineupInfo) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: OperatorName Tag: 0
    
        st[tlv.ContextTag(0)] = (s.OperatorName)
    
	// Field: LineupName Tag: 1
    if s.LineupName != nil {
        st[tlv.ContextTag(1)] = (*s.LineupName)
    }
	// Field: PostalCode Tag: 2
    if s.PostalCode != nil {
        st[tlv.ContextTag(2)] = (*s.PostalCode)
    }
	// Field: LineupInfoType Tag: 3
    
        st[tlv.ContextTag(3)] = uint64(s.LineupInfoType)
    
	return st
}

func (s *LineupInfo) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.OperatorName = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.LineupName = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(string); ok {
s.PostalCode = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := LineupInfoTypeEnum(v)
s.LineupInfoType = casted
}
        
        
	}

    return nil
}

type PageToken struct {
	Limit *uint16 // Tag 0
	After *string // Tag 1
	Before *string // Tag 2
}

func (s *PageToken) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Limit Tag: 0
    if s.Limit != nil {
        st[tlv.ContextTag(0)] = uint64(*s.Limit)
    }
	// Field: After Tag: 1
    if s.After != nil {
        st[tlv.ContextTag(1)] = (*s.After)
    }
	// Field: Before Tag: 2
    if s.Before != nil {
        st[tlv.ContextTag(2)] = (*s.Before)
    }
	return st
}

func (s *PageToken) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint16(v)
s.Limit = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.After = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Before = &v
}
        
        
	}

    return nil
}

type ProgramCast struct {
	Name string // Tag 0
	Role string // Tag 1
}

func (s *ProgramCast) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Name Tag: 0
    
        st[tlv.ContextTag(0)] = (s.Name)
    
	// Field: Role Tag: 1
    
        st[tlv.ContextTag(1)] = (s.Role)
    
	return st
}

func (s *ProgramCast) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Name = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Role = v
}
        
        
	}

    return nil
}

type ProgramCategory struct {
	Category string // Tag 0
	SubCategory *string // Tag 1
}

func (s *ProgramCategory) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Category Tag: 0
    
        st[tlv.ContextTag(0)] = (s.Category)
    
	// Field: SubCategory Tag: 1
    if s.SubCategory != nil {
        st[tlv.ContextTag(1)] = (*s.SubCategory)
    }
	return st
}

func (s *ProgramCategory) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Category = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.SubCategory = &v
}
        
        
	}

    return nil
}

type Program struct {
	Identifier string // Tag 0
	Channel ChannelInfo // Tag 1
	StartTime dm.EpochS // Tag 2
	EndTime dm.EpochS // Tag 3
	Title string // Tag 4
	Subtitle *string // Tag 5
	Description *string // Tag 6
	AudioLanguages []string // Tag 7
	Ratings []string // Tag 8
	ThumbnailUrl *string // Tag 9
	PosterArtUrl *string // Tag 10
	DvbiUrl *string // Tag 11
	ReleaseDate *string // Tag 12
	ParentalGuidanceText *string // Tag 13
	RecordingFlag RecordingFlagBitmap // Tag 14
	SeriesInfo *SeriesInfo // Tag 15
	CategoryList []ProgramCategory // Tag 16
	CastList []ProgramCast // Tag 17
	ExternalIDList []contentlauncher.AdditionalInfo // Tag 18
}

func (s *Program) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Identifier Tag: 0
    
        st[tlv.ContextTag(0)] = (s.Identifier)
    
	// Field: Channel Tag: 1
    
        st[tlv.ContextTag(1)] = s.Channel.Encode()
        
    
	// Field: StartTime Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.StartTime)
    
	// Field: EndTime Tag: 3
    
        st[tlv.ContextTag(3)] = uint64(s.EndTime)
    
	// Field: Title Tag: 4
    
        st[tlv.ContextTag(4)] = (s.Title)
    
	// Field: Subtitle Tag: 5
    if s.Subtitle != nil {
        st[tlv.ContextTag(5)] = (*s.Subtitle)
    }
	// Field: Description Tag: 6
    if s.Description != nil {
        st[tlv.ContextTag(6)] = (*s.Description)
    }
	// Field: AudioLanguages Tag: 7
    if len(s.AudioLanguages) > 0 {
        
        list := make(tlv.StringArray, 0, len(s.AudioLanguages))
        for _, v := range s.AudioLanguages {
            list = append(list, (v))
        }
        st[tlv.ContextTag(7)] = list
        
    }
	// Field: Ratings Tag: 8
    if len(s.Ratings) > 0 {
        
        list := make(tlv.StringArray, 0, len(s.Ratings))
        for _, v := range s.Ratings {
            list = append(list, (v))
        }
        st[tlv.ContextTag(8)] = list
        
    }
	// Field: ThumbnailUrl Tag: 9
    if s.ThumbnailUrl != nil {
        st[tlv.ContextTag(9)] = (*s.ThumbnailUrl)
    }
	// Field: PosterArtUrl Tag: 10
    if s.PosterArtUrl != nil {
        st[tlv.ContextTag(10)] = (*s.PosterArtUrl)
    }
	// Field: DvbiUrl Tag: 11
    if s.DvbiUrl != nil {
        st[tlv.ContextTag(11)] = (*s.DvbiUrl)
    }
	// Field: ReleaseDate Tag: 12
    if s.ReleaseDate != nil {
        st[tlv.ContextTag(12)] = (*s.ReleaseDate)
    }
	// Field: ParentalGuidanceText Tag: 13
    if s.ParentalGuidanceText != nil {
        st[tlv.ContextTag(13)] = (*s.ParentalGuidanceText)
    }
	// Field: RecordingFlag Tag: 14
    
        st[tlv.ContextTag(14)] = uint64(s.RecordingFlag)
    
	// Field: SeriesInfo Tag: 15
    if s.SeriesInfo != nil {
        st[tlv.ContextTag(15)] = s.SeriesInfo.Encode()
        
    }
	// Field: CategoryList Tag: 16
    if len(s.CategoryList) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.CategoryList))
        for _, v := range s.CategoryList {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(16)] = list
        
    }
	// Field: CastList Tag: 17
    if len(s.CastList) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.CastList))
        for _, v := range s.CastList {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(17)] = list
        
    }
	// Field: ExternalIDList Tag: 18
    if len(s.ExternalIDList) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.ExternalIDList))
        for _, v := range s.ExternalIDList {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(18)] = list
        
    }
	return st
}

func (s *Program) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Identifier = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        if err := s.Channel.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.StartTime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.EndTime = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Title = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Subtitle = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(6)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Description = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(7)]; ok {
        
            
            if arr, ok := val.(tlv.StringArray); ok {
                 for _, item := range arr {
                     s.AudioLanguages = append(s.AudioLanguages, string(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(8)]; ok {
        
            
            if arr, ok := val.(tlv.StringArray); ok {
                 for _, item := range arr {
                     s.Ratings = append(s.Ratings, string(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(9)]; ok {
        
        
            if v, ok := val.(string); ok {
s.ThumbnailUrl = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(10)]; ok {
        
        
            if v, ok := val.(string); ok {
s.PosterArtUrl = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(11)]; ok {
        
        
            if v, ok := val.(string); ok {
s.DvbiUrl = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(12)]; ok {
        
        
            if v, ok := val.(string); ok {
s.ReleaseDate = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(13)]; ok {
        
        
            if v, ok := val.(string); ok {
s.ParentalGuidanceText = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(14)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := RecordingFlagBitmap(v)
s.RecordingFlag = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(15)]; ok {
        
        s.SeriesInfo = &SeriesInfo{}
        if err := s.SeriesInfo.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(16)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem ProgramCategory
                    if err := newItem.Decode(item); err != nil { return err }
                    s.CategoryList = append(s.CategoryList, newItem)
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(17)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem ProgramCast
                    if err := newItem.Decode(item); err != nil { return err }
                    s.CastList = append(s.CastList, newItem)
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(18)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem contentlauncher.AdditionalInfo
                    if err := newItem.Decode(item); err != nil { return err }
                    s.ExternalIDList = append(s.ExternalIDList, newItem)
                 }
            }
            
        
	}

    return nil
}

type SeriesInfo struct {
	Season string // Tag 0
	Episode string // Tag 1
}

func (s *SeriesInfo) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Season Tag: 0
    
        st[tlv.ContextTag(0)] = (s.Season)
    
	// Field: Episode Tag: 1
    
        st[tlv.ContextTag(1)] = (s.Episode)
    
	return st
}

func (s *SeriesInfo) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Season = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Episode = v
}
        
        
	}

    return nil
}

