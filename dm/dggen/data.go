// Code generated by data_gen.go. DO NOT EDIT.

package dggen

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type BootReasonEnum uint8

const (
	BootReasonEnumUnspecified BootReasonEnum = 0
	BootReasonEnumPowerOnReboot BootReasonEnum = 1
	BootReasonEnumBrownOutReset BootReasonEnum = 2
	BootReasonEnumSoftwareWatchdogReset BootReasonEnum = 3
	BootReasonEnumHardwareWatchdogReset BootReasonEnum = 4
	BootReasonEnumSoftwareUpdateCompleted BootReasonEnum = 5
	BootReasonEnumSoftwareReset BootReasonEnum = 6
)

type HardwareFaultEnum uint8

const (
	HardwareFaultEnumUnspecified HardwareFaultEnum = 0
	HardwareFaultEnumRadio HardwareFaultEnum = 1
	HardwareFaultEnumSensor HardwareFaultEnum = 2
	HardwareFaultEnumResettableOverTemp HardwareFaultEnum = 3
	HardwareFaultEnumNonResettableOverTemp HardwareFaultEnum = 4
	HardwareFaultEnumPowerSource HardwareFaultEnum = 5
	HardwareFaultEnumVisualDisplayFault HardwareFaultEnum = 6
	HardwareFaultEnumAudioOutputFault HardwareFaultEnum = 7
	HardwareFaultEnumUserInterfaceFault HardwareFaultEnum = 8
	HardwareFaultEnumNonVolatileMemoryError HardwareFaultEnum = 9
	HardwareFaultEnumTamperDetected HardwareFaultEnum = 10
)

type InterfaceTypeEnum uint8

const (
	InterfaceTypeEnumUnspecified InterfaceTypeEnum = 0
	InterfaceTypeEnumWiFi InterfaceTypeEnum = 1
	InterfaceTypeEnumEthernet InterfaceTypeEnum = 2
	InterfaceTypeEnumCellular InterfaceTypeEnum = 3
	InterfaceTypeEnumThread InterfaceTypeEnum = 4
)

type NetworkFaultEnum uint8

const (
	NetworkFaultEnumUnspecified NetworkFaultEnum = 0
	NetworkFaultEnumHardwareFailure NetworkFaultEnum = 1
	NetworkFaultEnumNetworkJammed NetworkFaultEnum = 2
	NetworkFaultEnumConnectionFailed NetworkFaultEnum = 3
)

type RadioFaultEnum uint8

const (
	RadioFaultEnumUnspecified RadioFaultEnum = 0
	RadioFaultEnumWiFiFault RadioFaultEnum = 1
	RadioFaultEnumCellularFault RadioFaultEnum = 2
	RadioFaultEnumThreadFault RadioFaultEnum = 3
	RadioFaultEnumNFCFault RadioFaultEnum = 4
	RadioFaultEnumBLEFault RadioFaultEnum = 5
	RadioFaultEnumEthernetFault RadioFaultEnum = 6
)



type NetworkInterface struct {
	Name string // Tag 0
	IsOperational bool // Tag 1
	OffPremiseServicesReachableIPv4 *bool // Tag 2
	OffPremiseServicesReachableIPv6 *bool // Tag 3
	HardwareAddress dm.HardwareAddress // Tag 4
	IPv4Addresses []dm.IPv4Address // Tag 5
	IPv6Addresses []dm.IPv6Address // Tag 6
	Type InterfaceTypeEnum // Tag 7
}

func (s *NetworkInterface) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Name Tag: 0
    
        st[tlv.ContextTag(0)] = (s.Name)
    
	// Field: IsOperational Tag: 1
    
        st[tlv.ContextTag(1)] = (s.IsOperational)
    
	// Field: OffPremiseServicesReachableIPv4 Tag: 2
    if s.OffPremiseServicesReachableIPv4 != nil {
        st[tlv.ContextTag(2)] = (*s.OffPremiseServicesReachableIPv4)
    }
	// Field: OffPremiseServicesReachableIPv6 Tag: 3
    if s.OffPremiseServicesReachableIPv6 != nil {
        st[tlv.ContextTag(3)] = (*s.OffPremiseServicesReachableIPv6)
    }
	// Field: HardwareAddress Tag: 4
    
        st[tlv.ContextTag(4)] = []byte(s.HardwareAddress)
    
	// Field: IPv4Addresses Tag: 5
    if len(s.IPv4Addresses) > 0 {
        
        list := make(tlv.OctetStringArray, 0, len(s.IPv4Addresses))
        for _, v := range s.IPv4Addresses {
            list = append(list, []byte(v))
        }
        st[tlv.ContextTag(5)] = list
        
    }
	// Field: IPv6Addresses Tag: 6
    if len(s.IPv6Addresses) > 0 {
        
        list := make(tlv.OctetStringArray, 0, len(s.IPv6Addresses))
        for _, v := range s.IPv6Addresses {
            list = append(list, []byte(v))
        }
        st[tlv.ContextTag(6)] = list
        
    }
	// Field: Type Tag: 7
    
        st[tlv.ContextTag(7)] = uint64(s.Type)
    
	return st
}

func (s *NetworkInterface) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Name = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(bool); ok {
s.IsOperational = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(bool); ok {
s.OffPremiseServicesReachableIPv4 = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(bool); ok {
s.OffPremiseServicesReachableIPv6 = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.HardwareAddress = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
            
            if arr, ok := val.(tlv.OctetStringArray); ok {
                 for _, item := range arr {
                     s.IPv4Addresses = append(s.IPv4Addresses, dm.IPv4Address(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(6)]; ok {
        
            
            if arr, ok := val.(tlv.OctetStringArray); ok {
                 for _, item := range arr {
                     s.IPv6Addresses = append(s.IPv6Addresses, dm.IPv6Address(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(7)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := InterfaceTypeEnum(v)
s.Type = casted
}
        
        
	}

    return nil
}

