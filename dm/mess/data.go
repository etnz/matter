// Code generated by data_gen.go. DO NOT EDIT.

package mess

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type FutureMessagePreferenceEnum uint8

const (
	FutureMessagePreferenceEnumAllowed FutureMessagePreferenceEnum = 0
	FutureMessagePreferenceEnumIncreased FutureMessagePreferenceEnum = 1
	FutureMessagePreferenceEnumReduced FutureMessagePreferenceEnum = 2
	FutureMessagePreferenceEnumDisallowed FutureMessagePreferenceEnum = 3
	FutureMessagePreferenceEnumBanned FutureMessagePreferenceEnum = 4
)

type MessagePriorityEnum uint8

const (
	MessagePriorityEnumLow MessagePriorityEnum = 0
	MessagePriorityEnumMedium MessagePriorityEnum = 1
	MessagePriorityEnumHigh MessagePriorityEnum = 2
	MessagePriorityEnumCritical MessagePriorityEnum = 3
)

type MessageControlBitmap uint8

const (
	MessageControlBitmapConfirmationRequired MessageControlBitmap = 0x1
	MessageControlBitmapResponseRequired MessageControlBitmap = 0x2
	MessageControlBitmapReplyMessage MessageControlBitmap = 0x4
	MessageControlBitmapMessageConfirmed MessageControlBitmap = 0x8
	MessageControlBitmapMessageProtected MessageControlBitmap = 0x10
)



type MessageResponseOption struct {
	MessageResponseID uint32 // Tag 0
	Label string // Tag 1
}

func (s *MessageResponseOption) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: MessageResponseID Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.MessageResponseID)
    
	// Field: Label Tag: 1
    
        st[tlv.ContextTag(1)] = (s.Label)
    
	return st
}

func (s *MessageResponseOption) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint32(v)
s.MessageResponseID = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Label = v
}
        
        
	}

    return nil
}

type Message struct {
	MessageID dm.MessageID // Tag 0
	Priority MessagePriorityEnum // Tag 1
	MessageControl MessageControlBitmap // Tag 2
	StartTime *dm.EpochS // Tag 3
	Duration *uint64 // Tag 4
	MessageText string // Tag 5
	Responses []MessageResponseOption // Tag 6
}

func (s *Message) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: MessageID Tag: 0
    
        st[tlv.ContextTag(0)] = []byte(s.MessageID)
    
	// Field: Priority Tag: 1
    
        st[tlv.ContextTag(1)] = uint64(s.Priority)
    
	// Field: MessageControl Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.MessageControl)
    
	// Field: StartTime Tag: 3
    if s.StartTime != nil {
        st[tlv.ContextTag(3)] = uint64(*s.StartTime)
    }
	// Field: Duration Tag: 4
    if s.Duration != nil {
        st[tlv.ContextTag(4)] = uint64(*s.Duration)
    }
	// Field: MessageText Tag: 5
    
        st[tlv.ContextTag(5)] = (s.MessageText)
    
	// Field: Responses Tag: 6
    if len(s.Responses) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.Responses))
        for _, v := range s.Responses {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(6)] = list
        
    }
	return st
}

func (s *Message) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.([]byte); ok {
s.MessageID = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := MessagePriorityEnum(v)
s.Priority = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := MessageControlBitmap(v)
s.MessageControl = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := dm.EpochS(v)
s.StartTime = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint64(v)
s.Duration = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        
            if v, ok := val.(string); ok {
s.MessageText = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(6)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem MessageResponseOption
                    if err := newItem.Decode(item); err != nil { return err }
                    s.Responses = append(s.Responses, newItem)
                 }
            }
            
        
	}

    return nil
}

