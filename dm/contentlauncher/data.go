// Code generated by data_gen.go. DO NOT EDIT.

package contentlauncher

import (
	"fmt"

	"github.com/etnz/matter/tlv"
	"github.com/etnz/matter/dm"
	
	"github.com/etnz/matter/dm/mediaplayback"
	
)

var _ = dm.SubjectID(0)
var _ = tlv.Struct{}
var _ = fmt.Sprint()





type MetricTypeEnum uint8

const (
	MetricTypeEnumPixels MetricTypeEnum = 0
	MetricTypeEnumPercentage MetricTypeEnum = 1
)

type ParameterEnum uint8

const (
	ParameterEnumActor ParameterEnum = 0
	ParameterEnumChannel ParameterEnum = 1
	ParameterEnumCharacter ParameterEnum = 2
	ParameterEnumDirector ParameterEnum = 3
	ParameterEnumEvent ParameterEnum = 4
	ParameterEnumFranchise ParameterEnum = 5
	ParameterEnumGenre ParameterEnum = 6
	ParameterEnumLeague ParameterEnum = 7
	ParameterEnumPopularity ParameterEnum = 8
	ParameterEnumProvider ParameterEnum = 9
	ParameterEnumSport ParameterEnum = 10
	ParameterEnumSportsTeam ParameterEnum = 11
	ParameterEnumType ParameterEnum = 12
	ParameterEnumVideo ParameterEnum = 13
	ParameterEnumSeason ParameterEnum = 14
	ParameterEnumEpisode ParameterEnum = 15
	ParameterEnumAny ParameterEnum = 16
)

type StatusEnum uint8

const (
	StatusEnumSuccess StatusEnum = 0
	StatusEnumURLNotAvailable StatusEnum = 1
	StatusEnumAuthFailed StatusEnum = 2
	StatusEnumTextTrackNotAvailable StatusEnum = 3
	StatusEnumAudioTrackNotAvailable StatusEnum = 4
)

type SupportedProtocolsBitmap uint8

const (
	SupportedProtocolsBitmapDASH SupportedProtocolsBitmap = 0x1
	SupportedProtocolsBitmapHLS SupportedProtocolsBitmap = 0x2
)



type AdditionalInfo struct {
	Name string // Tag 0
	Value string // Tag 1
}

func (s *AdditionalInfo) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Name Tag: 0
    
        st[tlv.ContextTag(0)] = (s.Name)
    
	// Field: Value Tag: 1
    
        st[tlv.ContextTag(1)] = (s.Value)
    
	return st
}

func (s *AdditionalInfo) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Name = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Value = v
}
        
        
	}

    return nil
}

type BrandingInformation struct {
	ProviderName string // Tag 0
	Background *StyleInformation // Tag 1
	Logo *StyleInformation // Tag 2
	ProgressBar *StyleInformation // Tag 3
	Splash *StyleInformation // Tag 4
	WaterMark *StyleInformation // Tag 5
}

func (s *BrandingInformation) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: ProviderName Tag: 0
    
        st[tlv.ContextTag(0)] = (s.ProviderName)
    
	// Field: Background Tag: 1
    if s.Background != nil {
        st[tlv.ContextTag(1)] = s.Background.Encode()
        
    }
	// Field: Logo Tag: 2
    if s.Logo != nil {
        st[tlv.ContextTag(2)] = s.Logo.Encode()
        
    }
	// Field: ProgressBar Tag: 3
    if s.ProgressBar != nil {
        st[tlv.ContextTag(3)] = s.ProgressBar.Encode()
        
    }
	// Field: Splash Tag: 4
    if s.Splash != nil {
        st[tlv.ContextTag(4)] = s.Splash.Encode()
        
    }
	// Field: WaterMark Tag: 5
    if s.WaterMark != nil {
        st[tlv.ContextTag(5)] = s.WaterMark.Encode()
        
    }
	return st
}

func (s *BrandingInformation) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.ProviderName = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        s.Background = &StyleInformation{}
        if err := s.Background.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        s.Logo = &StyleInformation{}
        if err := s.Logo.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(3)]; ok {
        
        s.ProgressBar = &StyleInformation{}
        if err := s.ProgressBar.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(4)]; ok {
        
        s.Splash = &StyleInformation{}
        if err := s.Splash.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(5)]; ok {
        
        s.WaterMark = &StyleInformation{}
        if err := s.WaterMark.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type ContentSearch struct {
	ParameterList []Parameter // Tag 0
}

func (s *ContentSearch) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: ParameterList Tag: 0
    if len(s.ParameterList) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.ParameterList))
        for _, v := range s.ParameterList {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(0)] = list
        
    }
	return st
}

func (s *ContentSearch) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem Parameter
                    if err := newItem.Decode(item); err != nil { return err }
                    s.ParameterList = append(s.ParameterList, newItem)
                 }
            }
            
        
	}

    return nil
}

type Dimension struct {
	Width float64 // Tag 0
	Height float64 // Tag 1
	Metric MetricTypeEnum // Tag 2
}

func (s *Dimension) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Width Tag: 0
    
        st[tlv.ContextTag(0)] = (s.Width)
    
	// Field: Height Tag: 1
    
        st[tlv.ContextTag(1)] = (s.Height)
    
	// Field: Metric Tag: 2
    
        st[tlv.ContextTag(2)] = uint64(s.Metric)
    
	return st
}

func (s *Dimension) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(float64); ok {
s.Width = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(float64); ok {
s.Height = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := MetricTypeEnum(v)
s.Metric = casted
}
        
        
	}

    return nil
}

type Parameter struct {
	Type ParameterEnum // Tag 0
	Value string // Tag 1
	ExternalIDList []AdditionalInfo // Tag 2
}

func (s *Parameter) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: Type Tag: 0
    
        st[tlv.ContextTag(0)] = uint64(s.Type)
    
	// Field: Value Tag: 1
    
        st[tlv.ContextTag(1)] = (s.Value)
    
	// Field: ExternalIDList Tag: 2
    if len(s.ExternalIDList) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.ExternalIDList))
        for _, v := range s.ExternalIDList {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(2)] = list
        
    }
	return st
}

func (s *Parameter) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := ParameterEnum(v)
s.Type = casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Value = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem AdditionalInfo
                    if err := newItem.Decode(item); err != nil { return err }
                    s.ExternalIDList = append(s.ExternalIDList, newItem)
                 }
            }
            
        
	}

    return nil
}

type PlaybackPreferences struct {
	PlaybackPosition *uint64 // Tag 0
	TextTrack *TrackPreference // Tag 1
	AudioTracks []TrackPreference // Tag 2
}

func (s *PlaybackPreferences) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: PlaybackPosition Tag: 0
    if s.PlaybackPosition != nil {
        st[tlv.ContextTag(0)] = uint64(*s.PlaybackPosition)
    }
	// Field: TextTrack Tag: 1
    if s.TextTrack != nil {
        st[tlv.ContextTag(1)] = s.TextTrack.Encode()
        
    }
	// Field: AudioTracks Tag: 2
    if len(s.AudioTracks) > 0 {
        
        list := make(tlv.StructArray, 0, len(s.AudioTracks))
        for _, v := range s.AudioTracks {
            list = append(list, v.Encode())
        }
        st[tlv.ContextTag(2)] = list
        
    }
	return st
}

func (s *PlaybackPreferences) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint64(v)
s.PlaybackPosition = &casted
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        s.TextTrack = &TrackPreference{}
        if err := s.TextTrack.Decode(val); err != nil { return err }
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
            
            if list, ok := val.(tlv.StructArray); ok {
                 for _, item := range list {
                    var newItem TrackPreference
                    if err := newItem.Decode(item); err != nil { return err }
                    s.AudioTracks = append(s.AudioTracks, newItem)
                 }
            }
            
        
	}

    return nil
}

type StyleInformation struct {
	ImageURL *string // Tag 0
	Color *string // Tag 1
	Size *Dimension // Tag 2
}

func (s *StyleInformation) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: ImageURL Tag: 0
    if s.ImageURL != nil {
        st[tlv.ContextTag(0)] = (*s.ImageURL)
    }
	// Field: Color Tag: 1
    if s.Color != nil {
        st[tlv.ContextTag(1)] = (*s.Color)
    }
	// Field: Size Tag: 2
    if s.Size != nil {
        st[tlv.ContextTag(2)] = s.Size.Encode()
        
    }
	return st
}

func (s *StyleInformation) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.ImageURL = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
        
            if v, ok := val.(string); ok {
s.Color = &v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        s.Size = &Dimension{}
        if err := s.Size.Decode(val); err != nil { return err }
        
        
	}

    return nil
}

type TrackPreference struct {
	LanguageCode string // Tag 0
	Characteristics []mediaplayback.CharacteristicEnum // Tag 1
	AudioOutputIndex *uint8 // Tag 2
}

func (s *TrackPreference) Encode() tlv.Struct {
	st := make(tlv.Struct)
	// Field: LanguageCode Tag: 0
    
        st[tlv.ContextTag(0)] = (s.LanguageCode)
    
	// Field: Characteristics Tag: 1
    if len(s.Characteristics) > 0 {
        
        list := make(tlv.UintArray, 0, len(s.Characteristics))
        for _, v := range s.Characteristics {
            list = append(list, uint64(v))
        }
        st[tlv.ContextTag(1)] = list
        
    }
	// Field: AudioOutputIndex Tag: 2
    if s.AudioOutputIndex != nil {
        st[tlv.ContextTag(2)] = uint64(*s.AudioOutputIndex)
    }
	return st
}

func (s *TrackPreference) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected tlv.Struct, got %T", val)
	}
	if val, ok := st[tlv.ContextTag(0)]; ok {
        
        
            if v, ok := val.(string); ok {
s.LanguageCode = v
}
        
        
	}
	if val, ok := st[tlv.ContextTag(1)]; ok {
        
            
            if arr, ok := val.(tlv.UintArray); ok {
                 for _, item := range arr {
                     s.Characteristics = append(s.Characteristics, mediaplayback.CharacteristicEnum(item))
                 }
            }
            
        
	}
	if val, ok := st[tlv.ContextTag(2)]; ok {
        
        
            if v, ok := val.(uint64); ok {
casted := uint8(v)
s.AudioOutputIndex = &casted
}
        
        
	}

    return nil
}

