// Package securechannel implements the Matter Secure Channel protocol,
// including Passcode-Authenticated Session Establishment (PASE) and
// Certificate-Authenticated Session Establishment (CASE).
//
// This file defines the Go structures for the TLV-encoded payloads of
// the Secure Channel messages, as specified in the Matter Core Specification.
// These structures are used to serialize and deserialize the message bodies
// for PASE and CASE handshakes.
package securechannel

import (
	"bytes"
	"fmt"

	"github.com/etnz/matter/tlv"
)

// pbkdfParamRequest is the payload for the PBKDFParamRequest message (OpCode 0x20).
// It is the first message in the PASE protocol, sent by the initiator (commissioner)
// to request the parameters for the password-based key derivation function.
type pbkdfParamRequest struct {
	// InitiatorRandom is a 32-byte random number generated by the initiator.
	InitiatorRandom []byte
	// InitiatorSessionID is a 16-bit session ID chosen by the initiator.
	InitiatorSessionID uint16
	// PasscodeID is an identifier for the passcode being used.
	PasscodeID uint16
	// HasPBKDFParameters indicates if the initiator is proposing PBKDF parameters.
	HasPBKDFParameters bool
	// PBKDFParameters contains the proposed PBKDF parameters (iterations and salt).
	PBKDFParameters *pbkdfParameters
}

func (m *pbkdfParamRequest) Encode() tlv.Struct {
	s := tlv.Struct{
		tlv.ContextTag(1): m.InitiatorRandom,
		tlv.ContextTag(2): uint64(m.InitiatorSessionID),
		tlv.ContextTag(3): uint64(m.PasscodeID),
		tlv.ContextTag(4): m.HasPBKDFParameters,
	}
	if m.PBKDFParameters != nil {
		s[tlv.ContextTag(5)] = m.PBKDFParameters.Encode()
	}
	return s
}

func (m *pbkdfParamRequest) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.InitiatorRandom = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(2)]; ok {
		m.InitiatorSessionID = uint16(v.(uint64))
	}
	if v, ok := st[tlv.ContextTag(3)]; ok {
		m.PasscodeID = uint16(v.(uint64))
	}
	if v, ok := st[tlv.ContextTag(4)]; ok {
		m.HasPBKDFParameters = v.(bool)
	}
	if v, ok := st[tlv.ContextTag(5)]; ok {
		m.PBKDFParameters = &pbkdfParameters{}
		if err := m.PBKDFParameters.Decode(v); err != nil {
			return err
		}
	}
	return nil
}

// pbkdfParameters is a TLV structure containing the parameters for the PBKDF2 function.
type pbkdfParameters struct {
	// Iterations is the number of iterations for PBKDF2.
	Iterations uint32
	// Salt is the salt for PBKDF2, between 16 and 32 bytes.
	Salt []byte
}

func (m *pbkdfParameters) Encode() tlv.Struct {
	return tlv.Struct{
		tlv.ContextTag(1): uint64(m.Iterations),
		tlv.ContextTag(2): m.Salt,
	}
}

func (m *pbkdfParameters) Decode(val any) error {
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.Iterations = uint32(v.(uint64))
	}
	if v, ok := st[tlv.ContextTag(2)]; ok {
		m.Salt = v.([]byte)
	}
	return nil
}

// pbkdfParamResponse is the payload for the PBKDFParamResponse message (OpCode 0x21).
// It is sent by the responder (commissionee) in reply to a PBKDFParamRequest.
// It provides the PBKDF parameters that the initiator must use.
type pbkdfParamResponse struct {
	// InitiatorRandom is the random number received from the initiator's request.
	InitiatorRandom []byte
	// ResponderRandom is a 32-byte random number generated by the responder.
	ResponderRandom []byte
	// ResponderSessionID is a 16-bit session ID chosen by the responder.
	ResponderSessionID uint16
	// PBKDFParameters contains the PBKDF parameters (iterations and salt) chosen by the responder.
	PBKDFParameters *pbkdfParameters
}

func (m *pbkdfParamResponse) Encode() tlv.Struct {
	s := tlv.Struct{
		tlv.ContextTag(1): m.InitiatorRandom,
		tlv.ContextTag(2): m.ResponderRandom,
		tlv.ContextTag(3): uint64(m.ResponderSessionID),
	}
	if m.PBKDFParameters != nil {
		s[tlv.ContextTag(4)] = m.PBKDFParameters.Encode()
	}
	return s
}

func (m *pbkdfParamResponse) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.InitiatorRandom = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(2)]; ok {
		m.ResponderRandom = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(3)]; ok {
		m.ResponderSessionID = uint16(v.(uint64))
	}
	if v, ok := st[tlv.ContextTag(4)]; ok {
		m.PBKDFParameters = &pbkdfParameters{}
		if err := m.PBKDFParameters.Decode(v); err != nil {
			return err
		}
	}
	return nil
}

// pake1 is the payload for the PASEPake1 message (OpCode 0x22).
// It is sent by the initiator to begin the SPAKE2+ key exchange,
// containing the initiator's public key `pA`.
type pake1 struct {
	// PA is the initiator's SPAKE2+ public key.
	PA []byte
}

func (m *pake1) Encode() tlv.Struct {
	return tlv.Struct{
		tlv.ContextTag(1): m.PA,
	}
}

func (m *pake1) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.PA = v.([]byte)
	}
	return nil
}

// pake2 is the payload for the PASEPake2 message (OpCode 0x23).
// It is sent by the responder, containing its public key `pB` and
// a confirmation value `cB` to prove it has the shared secret.
type pake2 struct {
	// PB is the responder's SPAKE2+ public key.
	PB []byte
	// CB is the responder's confirmation data.
	CB []byte
}

func (m *pake2) Encode() tlv.Struct {
	return tlv.Struct{
		tlv.ContextTag(1): m.PB,
		tlv.ContextTag(2): m.CB,
	}
}

func (m *pake2) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.PB = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(2)]; ok {
		m.CB = v.([]byte)
	}
	return nil
}

// pake3 is the payload for the PASEPake3 message (OpCode 0x24).
// It is sent by the initiator, containing its confirmation value `cA`
// to prove it has the shared secret.
type pake3 struct {
	// CA is the initiator's confirmation data.
	CA []byte
}

func (m *pake3) Encode() tlv.Struct {
	return tlv.Struct{
		tlv.ContextTag(1): m.CA,
	}
}

func (m *pake3) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.CA = v.([]byte)
	}
	return nil
}

// caseSigma1 is the payload for the CASESigma1 message (OpCode 0x30).
// It is the first message in the CASE protocol, sent by the initiator to
// start a session with a peer on the same fabric.
type caseSigma1 struct {
	// InitiatorRandom is a 32-byte random number generated by the initiator.
	InitiatorRandom []byte
	// InitiatorSessionID is a 16-bit session ID chosen by the initiator.
	InitiatorSessionID uint16
	// DestinationID is a key identifier derived from the target node's operational ID and the fabric's IPK.
	DestinationID []byte
	// InitiatorEphPubKey is the initiator's ephemeral public key for the ECDH key exchange.
	InitiatorEphPubKey []byte
	// ResumptionID is used for session resumption.
	ResumptionID []byte
	// ResumeMIC is a message integrity code for session resumption.
	ResumeMIC []byte
}

func (m *caseSigma1) Encode() tlv.Struct {
	s := tlv.Struct{
		tlv.ContextTag(1): m.InitiatorRandom,
		tlv.ContextTag(2): uint64(m.InitiatorSessionID),
		tlv.ContextTag(3): m.DestinationID,
		tlv.ContextTag(4): m.InitiatorEphPubKey,
	}
	if len(m.ResumptionID) > 0 {
		s[tlv.ContextTag(5)] = m.ResumptionID
	}
	if len(m.ResumeMIC) > 0 {
		s[tlv.ContextTag(6)] = m.ResumeMIC
	}
	return s
}

func (m *caseSigma1) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.InitiatorRandom = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(2)]; ok {
		m.InitiatorSessionID = uint16(v.(uint64))
	}
	if v, ok := st[tlv.ContextTag(3)]; ok {
		m.DestinationID = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(4)]; ok {
		m.InitiatorEphPubKey = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(5)]; ok {
		m.ResumptionID = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(6)]; ok {
		m.ResumeMIC = v.([]byte)
	}
	return nil
}

// caseSigma2 is the payload for the CASESigma2 message (OpCode 0x31).
// It is the responder's reply in the CASE protocol.
type caseSigma2 struct {
	// ResponderRandom is a 32-byte random number generated by the responder.
	ResponderRandom []byte
	// ResponderSessionID is a 16-bit session ID chosen by the responder.
	ResponderSessionID uint16
	// ResponderEphPubKey is the responder's ephemeral public key for the ECDH key exchange.
	ResponderEphPubKey []byte
	// Encrypted contains the encrypted caseSigma2Signed payload.
	Encrypted []byte
}

func (m *caseSigma2) Encode() tlv.Struct {
	return tlv.Struct{
		tlv.ContextTag(1): m.ResponderRandom,
		tlv.ContextTag(2): uint64(m.ResponderSessionID),
		tlv.ContextTag(3): m.ResponderEphPubKey,
		tlv.ContextTag(4): m.Encrypted,
	}
}

func (m *caseSigma2) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.ResponderRandom = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(2)]; ok {
		m.ResponderSessionID = uint16(v.(uint64))
	}
	if v, ok := st[tlv.ContextTag(3)]; ok {
		m.ResponderEphPubKey = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(4)]; ok {
		m.Encrypted = v.([]byte)
	}
	return nil
}

// caseSigma2Signed (TBEData2) is the encrypted data within a CASESigma2 message.
// It contains the responder's identity and proof of possession of its private key.
type caseSigma2Signed struct {
	// ResponderNOC is the responder's Node Operational Certificate.
	ResponderNOC []byte
	// ResponderICAC is the responder's Intermediate CA Certificate (optional).
	ResponderICAC []byte
	// Signature is the responder's signature over the session transcript.
	Signature []byte
	// ResumptionID is used for session resumption.
	ResumptionID []byte
}

func (m *caseSigma2Signed) Encode() tlv.Struct {
	s := tlv.Struct{
		tlv.ContextTag(1): m.ResponderNOC,
		tlv.ContextTag(3): m.Signature,
	}
	if len(m.ResponderICAC) > 0 {
		s[tlv.ContextTag(2)] = m.ResponderICAC
	}
	if len(m.ResumptionID) > 0 {
		s[tlv.ContextTag(4)] = m.ResumptionID
	}
	return s
}

func (m *caseSigma2Signed) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.ResponderNOC = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(2)]; ok {
		m.ResponderICAC = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(3)]; ok {
		m.Signature = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(4)]; ok {
		m.ResumptionID = v.([]byte)
	}
	return nil
}

// caseSigma3 is the payload for the CASESigma3 message (OpCode 0x32).
// It is the initiator's final message in the CASE handshake.
type caseSigma3 struct {
	// Encrypted contains the encrypted caseSigma3Signed payload.
	Encrypted []byte
}

func (m *caseSigma3) Encode() tlv.Struct {
	return tlv.Struct{
		tlv.ContextTag(1): m.Encrypted,
	}
}

func (m *caseSigma3) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.Encrypted = v.([]byte)
	}
	return nil
}

// caseSigma3Signed (TBEData3) is the encrypted data within a CASESigma3 message.
// It contains the initiator's identity and proof of possession of its private key.
type caseSigma3Signed struct {
	// InitiatorNOC is the initiator's Node Operational Certificate.
	InitiatorNOC []byte
	// InitiatorICAC is the initiator's Intermediate CA Certificate (optional).
	InitiatorICAC []byte
	// Signature is the initiator's signature over the session transcript.
	Signature []byte
}

func (m *caseSigma3Signed) Encode() tlv.Struct {
	s := tlv.Struct{
		tlv.ContextTag(1): m.InitiatorNOC,
		tlv.ContextTag(3): m.Signature,
	}
	if len(m.InitiatorICAC) > 0 {
		s[tlv.ContextTag(2)] = m.InitiatorICAC
	}
	return s
}

func (m *caseSigma3Signed) Decode(data []byte) error {
	val, err := tlv.Decode(bytes.NewReader(data))
	if err != nil {
		return err
	}
	st, ok := val.(tlv.Struct)
	if !ok {
		return fmt.Errorf("expected struct, got %T", val)
	}
	if v, ok := st[tlv.ContextTag(1)]; ok {
		m.InitiatorNOC = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(2)]; ok {
		m.InitiatorICAC = v.([]byte)
	}
	if v, ok := st[tlv.ContextTag(3)]; ok {
		m.Signature = v.([]byte)
	}
	return nil
}

// caseSigma3TBS (To-Be-Signed) is the data structure over which the initiator
// creates its signature for the CASESigma3 message. It is not sent over the wire itself.
type caseSigma3TBS struct {
	// InitiatorNOC is the initiator's Node Operational Certificate.
	InitiatorNOC []byte
	// InitiatorICAC is the initiator's Intermediate CA Certificate (optional).
	InitiatorICAC []byte
	// InitiatorEphPubKey is the initiator's ephemeral public key.
	InitiatorEphPubKey []byte
	// ResponderEphPubKey is the responder's ephemeral public key.
	ResponderEphPubKey []byte
}

func (m *caseSigma3TBS) Encode() tlv.Struct {
	s := tlv.Struct{
		tlv.ContextTag(1): m.InitiatorNOC,
		tlv.ContextTag(3): m.InitiatorEphPubKey,
		tlv.ContextTag(4): m.ResponderEphPubKey,
	}
	if len(m.InitiatorICAC) > 0 {
		s[tlv.ContextTag(2)] = m.InitiatorICAC
	}
	return s
}
